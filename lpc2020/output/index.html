<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Security Related Flags: a Common GCC/LLVM View</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="font.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress" data-transition-duration="150"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="intro">Intro</h1><p>Security countermeasure strikes at several level:</p><ul><li>hardware (buy a new machine)</li><li>microcode (update your kernel)</li><li><strong>compiler</strong> (pick compiler flags)</li><li>codebase (update your code)</li></ul></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="always-two-they-are">Always Two They Are</h1><p>GCC Toolchain (mostly gcc + ld.bfd)</p><p>LLVM Toolchain (mostly clang + lld)</p></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="security-related-flags-a-common-gcc-llvm-view">Security Related Flags: a Common GCC/LLVM View</h1><p><strong>Serge &#xAB; sans paille &#xBB; Guelton</strong></p><p>Compiler Engineer / Wood Craft Lover / RedHat employee</p><p><strong>LPC'20 &#x2014; 26th of August 2020</strong></p></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="default-fedora-flags-x86-64">Default Fedora Flags (X86_64)</h1><pre class="highlight code">-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2
-Wp,-D_GLIBCXX_ASSERTIONS -fexceptions -fstack-protector-strong
-grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1
-specs=/usr/lib/rpm/redhat/redhat-annobin-cc1 -m64 -mtune=generic
-fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection
-Wl,-z,relro -Wl,--as-needed  -Wl,-z,now
-specs=/usr/lib/rpm/redhat/redhat-hardened-ld</pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="default-debian-flags-x86-64">Default Debian Flags (X86_64)</h1><pre class="highlight code">-g -O2
-fdebug-prefix-map=/home/sylvestre/dev/debian/pkg-llvm/llvm-toolchain/branches=.
-fstack-protector-strong -Wformat -Werror=format-security
-Wl,-z,relro</pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="common-library-exploitation">Common Library Exploitation</h1><p><em>Attack</em>: Exploit standard C/C++ functions misuse</p><p><em>Countermeasure</em>: Provide fortified version of these functions</p><p><em>Flag</em>: <tt>-D_FORTIFY_SOURCE</tt> (gcc, clang for builtin supports), <tt>-D_GLIBCXX_ASSERTIONS</tt></p><p><em>Overhead</em>: low (fortify) to high (asserts)</p><p><em>Artifact</em>: <tt>nm a.out | grep __strcpy_chk</tt></p></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="common-formating-attacks">Common Formating Attacks</h1><p><em>Attack</em>: Exploit user-controlled formating arguments</p><p><em>Countermeasure</em>: Warn about dubious patterns</p><p><em>Flag</em>: <tt>-Werror=format-security</tt> (gcc, clang)</p><p><em>Overhead</em>: nop (compile time)</p></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="common-code-overflows">Common Code Overflows</h1><p><em>Attack</em>: Exploit buffer overflow</p><p><em>Countermeasure</em>: Range analysis</p><p><em>Flag</em>: <tt>-Werror=array-bounds</tt> (gcc, clang)</p><p><em>Overhead</em>: nop (compile time)</p></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="uninitialized-stack-variables">Uninitialized Stack Variables</h1><p><em>Attack</em>: Use unitialized variable to leak previous state</p><p><em>Coutermeasure</em>: Always initialize stack variable</p><p><em>Flag</em>: <tt>-ftrivial-auto-var-init=pattern</tt> (clang)</p><p><em>Overhead</em>: yes (?)</p></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="got-plt-overwrite">GOT / PLT Overwrite</h1><p><em>Attack</em>: Overwrite the GOT/PLT to overwrite executable sections</p><p><em>Countermeasure</em>: Load everything then mark GOT/PLT read-only</p><p><em>Flag</em>: <tt>-Wl,-z,norelro</tt> (ld.bfd, lld), <tt>-Wl,-z,now</tt> (ld.bfd, lld)</p><p><em>Overhead</em>: increased startup time</p><p><em>Artifact</em>: <tt>readelf -a now | grep BIND_NOW</tt></p></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="executable-stack">Executable Stack</h1><p><em>Attack</em>: Overwrite an executable stack with malicious code</p><p><em>Countermeasure</em>: Mark the stack as non-executable</p><p><em>Flag</em>: <tt>-Wl,-z,noexecstack</tt> (ld.bfd, lld)</p><p><em>Overhead</em>: nop (?)</p><p><em>Artifact</em>: <tt>readelf -e a.out | grep -E 'GNU_STACK.*RWE'</tt></p></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="security-through-diversity">Security through Diversity</h1><p><em>Attack</em>: Use hardcoded adress in shellcodes/others</p><p><em>Countermeasure</em>: Randomize process adresses (ASLR)</p><p><em>Flag</em>: <tt>-pie -fPIE</tt> or <tt>-fPIC</tt> (gcc/ld.bfd, clang/lld) + <tt>/proc/sys/kernel/randomize_va_space</tt></p><p><em>Overhead</em>: relative jump computation</p><p><em>Artefact</em>: <tt>readelf -e a.out | grep 'DYN (Shared object file)'</tt></p></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="stack-clash">Stack Clash</h1><p><em>Attack</em>: Make the stack and the heap grow so that they overlap</p><p><em>Countermeasure</em>: Probe each page to trigger the kernel page guard</p><p><em>Flag</em>: <tt>-fstack-clash-protector</tt> (gcc, clang)</p><p><em>Overhead</em>: only for functions with large / dynamic stack alloc</p><p><em>Artefact</em>: <tt>objdump -S a.out | grep 'subq 4096, %rsp'</tt></p></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="stack-smash">Stack Smash</h1><p><em>Attack</em>: Modify the stack thanks to an overflow</p><p><em>Countermeasure</em>: Stack Canary</p><p><em>Flag</em>: <tt>-fstack-protector</tt> (gcc, clang), <tt>-fsanitize=safe-stack</tt> (clang)</p><p><em>Overhead</em>: one check per function, user-controlled granularity</p><p><em>Artefact</em>: <tt>nm a.out | grep __stack_chk_fail</tt></p></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="and-now-for-something-different">And now for something different</h1><p>All these slides were pretty classic, right?</p></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="spectre-v1">Spectre V1</h1><p><em>Attack</em>: Trick branch prediction into filling the cache with secret data</p><p><em>Countermeasure</em>: create a data dependency between data access and predicate state</p><p><em>Flag</em>: <tt>-mspeculative-load-hardening</tt> (clang)</p><p><em>Overhead</em>: non-neglectible (todo: add ref)</p></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="spectre-v2">Spectre V2</h1><p><em>Attack</em>: Trick branch prediction into executing a controlled function pointer</p><p><em>Countermeasure</em>: Use return prediction instead of branch prediction</p><p><em>Flag</em>: <tt>-mretpoline</tt> (clang) <tt>-mindirect-branch, -mfunction-return</tt> (gcc)</p><p><em>Overhead</em>: non-neglectible (todo: add ref)</p></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="return-oriented-programing">Return Oriented Programing</h1><p><em>Attack</em>: Execute arbitrary code through a chain of gadget</p><p><em>Countermeasure</em>: Check Control Flow Integrity / Intel CET</p><p><em>Flag</em>: <tt>-fsanitize=cfi</tt> (clang) <tt>-mcet</tt> (clang, gcc) <tt>-fcf-protection</tt> (clang,
gcc)</p></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="certification">Certification</h1><p>Want to double-check the flags used in the build process?</p><ul><li><tt>-fplugin=annobin</tt> (gcc, clang)</li><li><tt>-[fg]record-gcc-switches</tt> (gcc)</li></ul><p><em>Artefact</em>: <tt>readelf a.out -p .GCC.command.line | grep record-gcc-switches</tt></p></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="post-compilation-check">Post-Compilation Check</h1><p>For each compiler flag, test for harderning artefacts, <em>&#xE0; la</em>
<tt>hardening-check</tt>.</p><p><a href="https://github.com/serge-sans-paille/hardening-artefacts">https://github.com/serge-sans-paille/hardening-artefacts</a></p></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="example-stack-clash-protection">Example: Stack Clash Protection</h1><ul><li>LLVM implem using the GCC implem as reference</li><li>Different Test beds (GCC: compiler report, LLVM: assembly reference)</li><li>Paths to explore<blockquote><ul><li>instrumentation-based verification of distance invariant?</li><li>Static verification?</li></ul></blockquote></li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="follow-ups">Follow-ups</h1><ul><li>Convergence of options names is ~OK</li><li>But beside names, implementation differ!<ul><li>Discussing implementation across mlist (or on a common medium?)</li><li>Sharing compiler-agnostic test beds?</li></ul></li><li>Thanks to Adrien Guinet, Juan Manuel Martinez and Florian Weimer!</li></ul></div></div><div id="slide-number" class="slide-number">
         1
      </div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script><script type="text/javascript">
      document.getElementById("impress").addEventListener("impress:stepenter", update_slide_number, false);
    </script></body></html>